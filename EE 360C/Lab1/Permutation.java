import java.util.ArrayList;
import java.util.Arrays;

public class Permutation {
    private int n;
    private int k;
    private boolean allowEmptySpots;

    private int[] tenantCounts;
    private int[] pairing;
    private boolean done;

    /**
     * Initialize a permutation which will select pairings of apartments to tenants.
     * There should be at most p pairings. No pairing should be used more than
     * once. No apartment should be used more than once.
     * 
     * @param n
     *            Number of tenants.
     * @param k
     *            Number of apartments available.
     */
    public Permutation(int n, int k, boolean allowEmptyPositions) {
        this.n = n;
        this.k = k;
        this.allowEmptySpots = allowEmptyPositions;

        this.tenantCounts = new int[this.n];
        Arrays.fill(this.tenantCounts, 0);
        this.pairing = new int[this.k];

        if (allowEmptyPositions) {
            Arrays.fill(this.pairing, -1);
        } else {
            Arrays.fill(this.pairing, 0);
            this.tenantCounts[0] = this.pairing.length;
        }

        this.done = false;
    }
    
    public Permutation(int n) {
        this(n, n, false);
    }
    
    public Permutation(int n, int k) {
        this(n, k, false);
    }

	/**
	 * Return the next permutation as a Matching object, representing a solution
	 * to the Stable Matching problem contained in data.
	 * 
	 * @param data
	 *            The Matching object containing the problem to solve.
	 * @return The next candidate solution to the problem.
	 */
    public Matching getNextMatching(Matching data) {
        int[] pairing = getNextPairing();
        if (pairing == null) {
            return null;
        }

        Matching matching = convertPairingToMatching(data, pairing);
        return matching;
    }

    /**
     * Return a Matching (StableMatching candidate) constructed from the int[]
     * generated by getNextPairing().
     * 
     * @param data
     *            The Matching object containing the problem to solve.
     * @param pairing
     *            The candidate solution as generated by getNextPairing.
     * @return The Matching corresponding to the provided pairing.
     */
    private Matching convertPairingToMatching(Matching data, int[] pairing) {

        int n = data.getTenantCount();

        int pairing_index = 0;
        ArrayList<Integer> tenant_matching = new ArrayList<Integer>(0);
        for (int i = 0; i < n; i++) {
            tenant_matching.add(-1);
        }

        for (int i = 0; i < n; i++) {
                if (pairing[pairing_index] != -1) {
                    tenant_matching.set(pairing[pairing_index], i);
                }
                pairing_index++;
            }

        return new Matching(data, tenant_matching);
    }

    /**
     * Select the next pairing in "ascending order." Each tenant can be
     * assigned to at most one apartment, and each apartment can be assigned to at most
     * one tenant. Therefore, the length of the returned array will be n, and each apartment in the
     * array will contain the index of tenant which will fill occupy that apartment.
     * 
     * Values for the tenant range from 0 to n-1, so let the counting system
     * be a base-n counting system. Each apartment in the array must contain an
     * integer in [0,n-1] and when a position in the array wraps around, the
     * next highest position is incremented.
     * 
     * Keep track of the number of instances of a given tenant's number are
     * present in the pairing. A pairing is only valid if each tenant is paired
     * with a position at most 1 time.
     */
    private int[] getNextPairing() {
        if (done) {
            return null;
        }

        do {
            incrementPairing(0);
        } while (!isValidPairing());

        int[] nextPairing = new int[pairing.length];
        System.arraycopy(pairing, 0, nextPairing, 0, pairing.length);
        return nextPairing;
    }

    private boolean isValidPairing() {
        for (int x : tenantCounts) {
            if (x > 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Increment one position of the pairing and update arrays appropriately.
     * 
     * @param index
     *            The index of the array to increment.
     */
    private void incrementPairing(int index) {
        if (index == 0) {
        }

        if (index >= pairing.length) {
            done = true;
            return;
        }

        removeTenant(pairing[index]);

        // update tenant in matching
        pairing[index]++;
        if (pairing[index] >= n) {
            if (allowEmptySpots) {
                pairing[index] = -1;
            } else {
                pairing[index] = 0;
            }

            incrementPairing(index + 1);
        }

        addTenant(pairing[index]);
    }



    private void updateTenant(int tenant, int update) {
        if (tenant == -1 || tenant >= n) {
            return;
        }

        tenantCounts[tenant] += update;
    }

    private void removeTenant(int tenant) {
        updateTenant(tenant, -1);
    }

    private void addTenant(int tenant) {
        updateTenant(tenant, 1);
    }
}
